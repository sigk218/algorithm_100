README

11. [11_baekjoon_17822](./11_baekjoon_17822.py)

    - 문제 푼 시간: 59m
    
    - 117920/ 276
    
    - 전체적으로 회전 - 같은 수 찾기 - 삭제 or 보강이 반복된다.
    
    - 같은수를 찾을 때, idex= 0 과 idex =M 도 고려 해야한다.
    
    -  문제에서 x 표시 한 것을 0 으로 표시하고 풀었는데, 이때 해당 칸을 고려하지 않도록 코드를 짜야한다. (cnt나 보강시 고려해서는 안됨)
    
    - 나누기 할 때, **분모가 0**인 경우를 고려할 것! (런타임에러가 난다. ㅜㅜ)
    
    - 다른 사람의 코드 중에는 나누기 대신, 곱하기로 검사한 사람이 있었다.
    
      ```python
      if onepan[i][j] * cnt > total:
          onepan[i][j] -= onepan[i][j]
      elif onepan[i][j] * cnt < total:
          onepan[i][j] += onepan[i][j]
      ```
    
      이런식으로 하면, 에러날 일이 없다! 


​    

13. [13_baekjoon_10844](./13_baekjoon_10844.py)
- 115436/140
  
    - 처음에는 dfs로 풀었다가, 시간초과가 났다. 
    
    - dp memoization을 써야하는 문제.. ! 
    
    - 예외처리에 대해서 고민해봐야 한다.
    
    - top-down 방식으로 풀이할 수 도 있다. (잘 이해가 안된다.)

14. [14_baekjoon_16235](./14_baekjoon_16235.py) 🌟🌟
    - 문제 푼 시간 : 2h 17m 했지만... 못풀었다...😭
    
    - 1000번이라면, 죽은 나무와 살아있는 나무를 분리해서 생각 했어야함..!
    
    - 인덱스가 어디서 시작 하는 지 체크!
    
    - [참고](https://dailyheumsi.tistory.com/60) 해서 코드를 다시 짜보았다.
    
    - deque를 이용해서 dict_map을 그리는 방법이 유용함...!
    
    - 그럼에도 불구하고 시간초과가 뜬다.. (37%에서..)..😭
    
    - 나중에.. 다시도전..
    
      
